<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Geometry Dash Clone</title>
    <style>
        body {
            margin: 0;
            background-color: #000;
            display: flex;
            justify-content: center;
            align-items: center;
            height: 100vh;
        }
        canvas {
            background-color: #222;
        }
    </style>
</head>
<body>
    <canvas id="gameCanvas"></canvas>

    <script>
        const canvas = document.getElementById("gameCanvas");
        const ctx = canvas.getContext("2d");

        // Set the canvas size
        canvas.width = 800;
        canvas.height = 400;

        // Game variables
        let player = { x: 50, y: 300, width: 50, height: 50, speedY: 0, gravity: 0.8, jumpPower: -15, hasCoat: false };
        let obstacles = [];
        const obstacleSpeed = 5;
        let gameOver = false;
        let score = 0;
        let showHitboxes = false;
        const minObstacleDistance = 200;
        const obstacleWidth = 50;
        const obstacleHeight = 50;

        // Grace period hitbox (smaller than the spike)
        const hitboxShrinkFactor = 0.8;

        // Load coat ownership from local storage
        function loadCoat() {
            const hasCoat = localStorage.getItem('hasCoat') === 'true';
            player.hasCoat = hasCoat;
        }

        // Grant coat at score 10
        function grantCoat() {
            if (score >= 10) {
                player.hasCoat = true;
                localStorage.setItem('hasCoat', 'true'); // Save to local storage
            }
        }

        // Function to create new obstacles
        function createObstacle() {
            const yPos = canvas.height - obstacleHeight;
            const lastObstacle = obstacles[obstacles.length - 1];

            if (!lastObstacle || lastObstacle.x < canvas.width - minObstacleDistance) {
                obstacles.push({ x: canvas.width, y: yPos, width: obstacleWidth, height: obstacleHeight });
            }
        }

        // Handle jump
        function jump() {
            if (player.y + player.height >= canvas.height) {
                player.speedY = player.jumpPower;
            }
        }

        // Restart the game
        function restartGame() {
            gameOver = false;
            score = 0;
            player = { x: 50, y: 300, width: 50, height: 50, speedY: 0, gravity: 0.8, jumpPower: -15, hasCoat: localStorage.getItem('hasCoat') === 'true' };
            obstacles = [];
            gameLoop();
        }

        // Handle key press
        document.addEventListener('keydown', function (event) {
            if (event.code === 'Space' || event.code === 'KeyW') {
                if (!gameOver) jump();
            }
            if (event.code === 'KeyR' && gameOver) {
                restartGame();
            }
            if (event.code === 'KeyO') {
                showHitboxes = !showHitboxes; // Press O to toggle hitbox visibility
            }
        });

        // Draw player
        function drawPlayer() {
            ctx.fillStyle = "#FF6347";
            ctx.fillRect(player.x, player.y, player.width, player.height);

            // Draw coat if player has it
            if (player.hasCoat) {
                drawCoat();
            }
        }

        // Draw obstacles (triangles)
        function drawObstacle(obstacle) {
            ctx.fillStyle = "#FF0000";
            ctx.beginPath();
            ctx.moveTo(obstacle.x, obstacle.y + obstacle.height);
            ctx.lineTo(obstacle.x + obstacle.width / 2, obstacle.y);
            ctx.lineTo(obstacle.x + obstacle.width, obstacle.y + obstacle.height);
            ctx.closePath();
            ctx.fill();
        }

        // Draw improved coat on player
        function drawCoat() {
            const coatX = player.x + (player.width / 2) - 25; // Center the coat horizontally
            const coatY = player.y - 50; // Position the coat above the player

            // Draw the coat's main body
            ctx.fillStyle = "#0000FF"; // Blue color for the coat
            ctx.fillRect(coatX, coatY, 50, 30); // Draw the coat

            // Draw collar
            ctx.fillStyle = "#003366"; // Darker blue for collar
            ctx.fillRect(coatX + 15, coatY - 10, 20, 10); // Draw collar

            // Draw sleeves
            ctx.fillStyle = "#0000FF"; // Blue color for sleeves
            ctx.fillRect(coatX - 10, coatY + 5, 10, 20); // Left sleeve
            ctx.fillRect(coatX + 50, coatY + 5, 10, 20); // Right sleeve

            // Draw star in the middle of the coat
            ctx.fillStyle = "yellow";
            ctx.beginPath();
            ctx.moveTo(coatX + 25, coatY + 5);
            ctx.lineTo(coatX + 30, coatY + 20);
            ctx.lineTo(coatX + 45, coatY + 20);
            ctx.lineTo(coatX + 32, coatY + 30);
            ctx.lineTo(coatX + 37, coatY + 45);
            ctx.lineTo(coatX + 25, coatY + 35);
            ctx.lineTo(coatX + 13, coatY + 45);
            ctx.lineTo(coatX + 18, coatY + 30);
            ctx.lineTo(coatX + 0, coatY + 20);
            ctx.lineTo(coatX + 15, coatY + 20);
            ctx.closePath();
            ctx.fill();
        }

        // Draw hitboxes (smaller than the actual triangles)
        function drawHitbox(obstacle) {
            const hitboxWidth = obstacle.width * hitboxShrinkFactor;
            const hitboxHeight = obstacle.height * hitboxShrinkFactor;
            const hitboxX = obstacle.x + (obstacle.width - hitboxWidth) / 2;
            const hitboxY = obstacle.y + (obstacle.height - hitboxHeight) / 2;

            ctx.strokeStyle = "yellow";
            ctx.strokeRect(hitboxX, hitboxY, hitboxWidth, hitboxHeight);
        }

        // Check collision with smaller hitbox for grace period
        function checkCollision(obstacle) {
            const hitboxWidth = obstacle.width * hitboxShrinkFactor;
            const hitboxHeight = obstacle.height * hitboxShrinkFactor;
            const hitboxX = obstacle.x + (obstacle.width - hitboxWidth) / 2;
            const hitboxY = obstacle.y + (obstacle.height - hitboxHeight) / 2;

            return player.x < hitboxX + hitboxWidth &&
                   player.x + player.width > hitboxX &&
                   player.y < hitboxY + hitboxHeight &&
                   player.y + player.height > hitboxY;
        }

        // Game loop
        function gameLoop() {
            if (gameOver) {
                ctx.fillStyle = "#FFF";
                ctx.font = "40px Arial";
                ctx.fillText("Game Over! Press R to restart.", 100, canvas.height / 2);
                return;
            }

            // Clear the canvas
            ctx.clearRect(0, 0, canvas.width, canvas.height);

            // Update player
            player.speedY += player.gravity;
            player.y += player.speedY;
            if (player.y + player.height > canvas.height) {
                player.y = canvas.height - player.height;
                player.speedY = 0;
            }

            drawPlayer();

            // Move and draw obstacles
            obstacles.forEach((obstacle, index) => {
                obstacle.x -= obstacleSpeed;
                if (obstacle.x + obstacle.width < 0) {
                    obstacles.splice(index, 1); // Remove obstacle if off-screen
                    score++;
                    grantCoat(); // Check for coat after scoring
                }

                drawObstacle(obstacle);

                // Draw hitbox if hitboxes are enabled
                if (showHitboxes) {
                    drawHitbox(obstacle);
                }

                // Check collision
                if (checkCollision(obstacle)) {
                    gameOver = true;
                }
            });

            // Create obstacles periodically
            if (Math.random() < 0.02) {
                createObstacle();
            }

            // Display score
            ctx.fillStyle = "#FFF";
            ctx.font = "20px Arial";
            ctx.fillText("Score: " + score, 10, 20);

            // Continue the game loop
            requestAnimationFrame(gameLoop);
        }

        // Load the coat from local storage and start the game loop
        loadCoat();
        gameLoop();
    </script>
</body>
</html>
